

-- Basic concepts

-- List comprehension utilizes generators and | (as is drawn from)


-- Examples

concat1 :: [[a]] -> [a]
concat1 xss = [x | xs <- xss, x <- xs]

-- Explanation.
-- x is drawn from xs generated by xs, and xs is generated by xss

-- _ is called wild card pattern, this means that anything can take position at _

firsts :: [(a,b)] -> [a]
firsts ps = [x | (x, _) <- ps]


length1 :: [a] -> Int
length1 xs = sum [1 | _ <- xs]

-- _ doesn't matters, you can still discard with assignment
-- However, for readability it is better to indicate discarding with _

-- Guards can be used to for filtering out values during list comprehension

-- Guard is like a gate/filter

factors1 :: Int -> [Int]
factors1 n = [x | x <- [1..n], n `mod` x == 0]

-- Example primes
prime :: Int -> Bool
prime n = factors1 n == [1, n]

-- In Non-Lazy languages, all factors would have got calculated before returning false
-- but in haskell, we return false as soon as 2 factors are calculated where both aren't 1 and n in the 
-- same sequence
primes :: Int -> [Int]
primes n = [x | x <- [2..n], prime x]

-- Efficient method: Sieve of Eratosthenes

-- To make it type strict, we take Eq data type.
-- All types except IO are Eq typeclass
-- Finding index

find1 :: Eq a => a -> [(a, b)] -> [b]
find1 k t = [v | (k', v) <- t, k == k']


pairs :: [a] -> [(a, a)]
pairs xs = zip xs (tail xs)


sorted1 :: Ord a => [a] -> Bool
sorted1 xs = and [x <= y | (x, y) <- pairs xs]


positions1 :: Eq a => a -> [a] -> [Int]
positions1 x xs = [i | (x', i) <- zip xs [0..], x == x']



-- String comprehensions
-- Strings are just an abbreviation for list of chars in hascal.

-- Returns number of lower case letters
lowers :: String -> Int
lowers xs = length [x | x <- xs, x >= 'a' && x <= 'z']


count1 :: Char -> String -> Int
count1 k xs = length [k' | k' <- xs, k == k']


